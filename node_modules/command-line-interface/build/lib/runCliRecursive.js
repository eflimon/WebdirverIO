"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runCliRecursive = void 0;
const command_line_commands_1 = __importDefault(require("command-line-commands"));
const convertOptionDefinition_1 = require("./convertOptionDefinition");
const helpOption_1 = require("./commands/helpOption");
const validateOptions_1 = require("./validateOptions");
const command_line_args_1 = __importDefault(require("command-line-args"));
const errors = __importStar(require("./errors"));
const runCliRecursive = async function ({ command, argv, handlers, getUsage, recommendCommand, level, ancestorOptions, ancestorNames }) {
    const commandPath = [...ancestorNames, command.name];
    const optionDefinitions = command.optionDefinitions.
        map((optionDefinition) => (0, convertOptionDefinition_1.convertOptionDefinition)({ optionDefinition }));
    const optionDefinitionsWithHelp = [
        ...optionDefinitions,
        helpOption_1.helpOption
    ];
    // eslint-disable-next-line @typescript-eslint/naming-convention
    const { _unknown, ...options } = (0, command_line_args_1.default)(optionDefinitionsWithHelp, { argv, stopAtFirstUnknown: true });
    if (options.help) {
        // eslint-disable-next-line no-console
        console.log(getUsage({ commandPath }));
        return;
    }
    try {
        (0, validateOptions_1.validateOptions)({ options, optionDefinitions: command.optionDefinitions });
    }
    catch (ex) {
        switch (ex.code) {
            case errors.OptionMissing.code:
                handlers.optionMissing({ optionDefinition: ex.data.optionDefinition });
                // eslint-disable-next-line unicorn/no-process-exit
                return process.exit(1);
            case errors.OptionInvalid.code: {
                handlers.optionInvalid({ optionDefinition: ex.data.optionDefinition, reason: ex.message });
                // eslint-disable-next-line unicorn/no-process-exit
                return process.exit(1);
            }
            default: {
                throw ex;
            }
        }
    }
    const mergedOptions = {
        ...ancestorOptions,
        ...options
    };
    if (_unknown === undefined || command.ignoreUnknownOptions) {
        try {
            return await command.handle({
                options: mergedOptions,
                getUsage,
                level,
                ancestors: ancestorNames
            });
        }
        catch (ex) {
            handlers.commandFailed({ ex });
            // eslint-disable-next-line unicorn/no-process-exit
            return process.exit(1);
        }
    }
    if (command.subcommands === undefined || Object.keys(command.subcommands).length === 0) {
        const unknowOption = _unknown[0];
        handlers.optionUnknown({ optionName: unknowOption });
        // eslint-disable-next-line unicorn/no-process-exit
        return process.exit(1);
    }
    try {
        const { command: subCommandName, argv: subArgv } = (0, command_line_commands_1.default)(Object.keys(command.subcommands), 
        // Pass a copy of the _unknown array, since the commandLineCommands
        // function mutates the parameter in-place. To avoid this, spread it and
        // wrap the values within a new array.
        [..._unknown]);
        const subCommand = command.subcommands[subCommandName];
        return await runCliRecursive({
            command: subCommand,
            argv: subArgv,
            handlers,
            getUsage,
            recommendCommand,
            level: level + 1,
            ancestorOptions: mergedOptions,
            ancestorNames: commandPath
        });
    }
    catch {
        const unknownCommand = _unknown[0];
        const recommendedCommand = recommendCommand({ commandPath: [...commandPath, unknownCommand] });
        handlers.commandUnknown({
            unknownCommandName: unknownCommand,
            recommendedCommandName: recommendedCommand,
            ancestors: ancestorNames
        });
        // eslint-disable-next-line unicorn/no-process-exit
        process.exit(1);
    }
};
exports.runCliRecursive = runCliRecursive;
